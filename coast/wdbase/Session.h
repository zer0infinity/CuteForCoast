/*
 * Copyright (c) 2005, Peter Sommerlad and IFS Institute for Software at HSR Rapperswil, Switzerland
 * All rights reserved.
 *
 * This library/application is free software; you can redistribute and/or modify it under the terms of
 * the license that is included with this library/application in the file license.txt.
 */

#ifndef _SESSION_H
#define _SESSION_H

//--- superclass interface
#include "Action.h"
#include "Threads.h"

class Role;
class Server;
class Context;
class Page;

//!manages session store and page transitions based on component objects
//!manages session store; this is memory that survives request invocation<p>
//!verifies the requests context information and implements the page transition algorithm
class Session : public NotCloned, public virtual LookupInterface
{
public:
	//!sessions are generated by factory methods of a server object
	//! \param name Name of the session, not very important since a session has no configuration yet
	Session(const char *name);
	//!destroyed by session cleaner or server shutdown; never call it directly unless you are sure what you are doing
	virtual ~Session();
	//!initializes session with session id and potentially additional context based data
	//! \param id unique session identifier
	//! \param ctx request context
	virtual void Init(const char *id, Context &ctx);
	//! this is the major entry point for request processing and computing the page transition
	//! initiates page postprocessing, performs the page/role transition, preprocesses the next page
	//! and generates the output, only active once at a time
	//! \param reply the way all answers go, usually a socket to a client browser
	//! \param ctx the Request Context for this call
	//! \param roaConfig Configuration which might be used by derived classes
	virtual bool RenderNextPage(std::ostream &reply, Context &ctx, const ROAnything &roaConfig);
	//! check if the preselected request arguments are sane for this session
	//! \param ctx request Context
	virtual bool Verify(Context &ctx);
	//!:queries termination flag; returns false if session is locked
	virtual bool IsTerminated();
	//!queries termination considers timeout, session lock, reference count
	virtual bool IsDeletable(long secs, Context &ctx, bool roleNotRelevant);
	//!resets access time and termination flag
	virtual void ResetTimeAndFlags();

	//!access to session id
	virtual const char *GetId() const;
	//!returns access counter of session
	virtual long GetAccessCounter() const;
	//!returns last access time
	virtual long GetAccessTime() const;
	//!resets last accesstime to now
	virtual void ResetAccessTime();
	//!returns true if mutex is locked else false
	virtual bool IsBusy();
	//!returns true, if we are holding the lock ourself
	virtual bool IsLockedByMe() {
		return fMutex.IsLockedByMe();
	}
	//!returns reference count to session
	virtual long GetRefCount() const;
	//! should only be used by Role::GetStoreGlobal() because we
	//! made Roles registerd singletons, Lookup is via Context::Lookup()
	virtual TrickyThing &GetRoleStoreGlobal();

	//! retrieve all relevant session state to a, used to create state information for
	//! intra-application hyperlinks
	//! \param a out-parameter with the link state added
	//! \param c the current request context
	virtual void CollectLinkState(Anything &a, Context &c) const;

	/*! Generate debug output onto reply;
		\param reply the stream to generate output to
		\param printAny either dump fStore if true or rely on Session.HTMLSessionStore to be enabled in Tracer.any */
	void HTMLDebugStore(std::ostream &reply, bool printAny = false);

	//! reply with a busy page
	virtual bool Info(Anything &info, Context &ctx);

	//!field name quoting with standard prefixes
	//! implemented here to be independent of RendererModule
	//! CAUTION: implicit dependency to FormRenderer and FieldRenderers
	static void Normalize(Anything &query);

	static const String FR_FIELDPREFIX;
	static const String FR_BUTTONPREFIX;
	static const String FR_IMAGEPREFIX;

	enum ESessionEvt {
		eAdded,
		eRemoved
	};
	//!notify session when added, removed, disabled from session list. (Overwrite this method.)
	virtual void Notify(ESessionEvt evt, Context &ctx);
	//! returns information about session
	virtual bool GetSessionInfo(Anything &sessionListInfo, Context &ctx, const char *slotName);
	//!returns configured timeout
	virtual long GetTimeout(Context &ctx) const;
	//! Get the current Role, returns default role
	virtual Role *GetRole(Context &ctx) const;
	//! getting the name of the current role
	virtual String GetRoleName(Context &ctx, String const &strDefaultRolename="") const;
	//! define the new role
	virtual void SetRole(Role *newRole, Context &ctx);

protected:
	//! unlocked render nextpage
	virtual bool DoRenderNextPage(std::ostream &reply, Context &context);
	//! prepare the context of the request and initialize transition and the pagename
	//! reply with a busy page
	virtual bool DoRenderBusyPage(std::ostream &reply, Context &ctx);
	virtual void SetupContext(Context &c, String &transition, String &pagename);
	//! check if role change is triggered by action and performs it
	//! uses /RoleChanges in context for lookup. This anything maps actions to role names
	//! \return returns 0 if this lookup fails with action
	//! the role returned might be the role we are already in
	//! \param action name of the transition that can trigger a role change
	//! \param context the current request context
	virtual Role *CheckRoleExchange(const char *action, Context &context) const;

	// implementing the state transition

	//!core page transition routine -- there is the beef
	virtual void DoFindNextPage(Context &context, String &action, String &pagename);

	//!adjust transition and pagename to force Login
	//! \param ctx request Context
	//! \param transition will get set to "Login"
	//! \param currentpage will get the name of \b StartPage
	void prepareForcedLogin(Context &ctx, String &transition, String &currentpage);
	//! mark tmpstore so that InReAuthenticate will return true later on
	void SetInReauthenticate(Context &context);
	//!check for recursive calls of ReAuthenticate on the same role
	virtual bool InReAuthenticate(Role *r, Context &context);
	//! postprocess page and perform action, return transition name in action
	//! \param context the context of the current request
	//! \param action the action to take in/out the transition to go
	//! \param pagename the old/last page where this request comes from
	virtual bool FinishPage(Context &context, String &action, String &pagename);
	//! preprocess the new page and provide a transition or failover page if preprocessing fails
	virtual bool PreparePage(Context &context, String &transition, String &currentpage);
	//! handle error conditions in page transition, e.g. no credentials, role misuse
	virtual void PrepareLogout(Context &context, String &transition, String &currentpage);
	//!check if role is insufficient or if the hook RequirePageInsert returns true
	virtual bool NeedsPageInsert(Context &context, String &action, String &pagename);
	//! hook to declare automatically inserted pages into the request stream
	virtual bool RequirePageInsert(Context &context, String &action, String &pagename);
	//! perform mechanics for page insertion (like login) if we need to
	virtual void SaveToDelayed(Context &context, String &transition, String &pagename);
	//!we come from an inserted page and this time we do what we remembered
	virtual bool RetrieveFromDelayed(Context &context, String &action, String &currentpage);
	//! check if role change is triggered by action and performs it
	//! additionally call hook CameFromPageInsert if there hasn't been a role change
	virtual bool AfterPageInsert(Context &context, String &action, String &pagename);
	//!hook for deciding if we have inserted a page
	//! an application can define its own strategy for this in addition to role insufficiency
	virtual bool CameFromPageInsert(Context &context, String &action, String &pagename);

	//!access to the session store
	//! <h3>*** CAUTION ***</h3>
	//! The Anything returned by GetStoreGlobal() is one of the few exceptions
	//! where the usual <b>reference semantics of Anything arrays may not apply!</b><br>
	//! <b>Reason: </b><p>
	//! The result is allocated within a global memory allocator rather than the
	//! pool allocator that is usually used when processing requests.
	//! Be aware that mixing differently allocated Anythings will always lead to the
	//! automatic copying into the allocator of the respective target Anything.
	//! Do use a globally allocated Anything to store the result of this method, e.g.
	//! "TrickyThing store(GetStoreGlobal());"
	virtual TrickyThing &GetStoreGlobal();

	//!access and insert into session store without mutex lock; beware of mt issues
	virtual void PutInStore(const char *key, const Anything &a);
	//!access and remove key from session store without mutex lock: beware of mt issues
	virtual void RemoveFromStore(const char *key);

	//! lookup session store
	virtual bool DoLookup(const char *key, ROAnything &result, char delim = '.', char indexdelim = ':') const;

	virtual void IntNotify(ESessionEvt evt, Context &ctx);

	//! Increase pending requests count for session
	virtual bool Ref();

	//! Decrease pending requests count for session
	virtual bool UnRef();

private:
	Session();
	Session(const Session &);
	Session &operator=(const Session &);

	// due to its changed semantics GetStore() has been
	// replaced by GetStoreGlobal() .. read the associated comments carefully
	virtual Anything &GetStore() {
		return GetStoreGlobal();
	}

	// entry point for testcases; invalidates session by setting last access time before timeout period
	bool MakeInvalid(Context &ctx);

protected:
	//! mutex guarding concurrent access
	Mutex 	 fMutex;
	//! flag for lazy termination
	bool 	 fTerminated;

	//! the session store
	TrickyThing fStore;
	//! internal session id
	String	 fId;
	//! the port we use to identify our server
	long	 fPort;
	//! the ip-number of our server if http-server and Coast are not on the same machine
	String	 fAddress;
	//! access counter
	long	 fAccessCounter;
	//! access time this triggers deletion if time(0) - fAccessTime > timeout
	long	 fAccessTime;
	//! the remote adress (browser or proxy) of my user
	String 	 fRemoteAddr;
	//! the browser info of the last request
	String 	 fBrowser;

	//! counts session in use
	long 	fRefCount;

	friend class Context;
	friend class SessionListManager;

	// for testing internals:
	friend class SessionTest;
	friend class SessionListManagerTest;
	friend class ContextTest;
	friend class DataAccessTest; // check for auto-unlocking
};

//! collects session information
class SessionInfo: public Action {
public:
	SessionInfo(const char *name) :
		Action(name) {
	}
	//! does the information collecting
	virtual bool DoExecAction(String &transitionToken, Context &ctx, const ROAnything &config);

protected:
	//! override in derived class to add more information to be showed
	virtual bool DoGetInfo(Session *s, Anything &info, Context &ctx);
};

#endif
