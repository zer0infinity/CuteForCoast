#!/bin/sh
# -------------------------------------------------------------------------
# Copyright (c) 2015, Peter Sommerlad and IFS Institute for Software
# at HSR Rapperswil, Switzerland
# All rights reserved.
#
# This library/application is free software; you can redistribute and/or
# modify it under the terms of the license that is included with this
# library/application in the file license.txt.
# -------------------------------------------------------------------------
# Autogenerated by SConsider; do not edit!

GDBSERVERPORT=2345

MYNAME="`basename \"$0\"`"
SCRIPTPATH="`dirname \"$0\"`"
SCRIPTPATH="`cd \"$SCRIPTPATH\" 2>/dev/null && pwd -P`"
STARTPATH="`pwd -P`"

doChangeDir=1
doDebug=0
doDebugServer=0
doTrace=0

showhelp()
{
    echo ''
    echo 'usage: '$MYNAME' [options]'
    echo 'where options are:'
    echo ' -d            : run under debugger control (gdb)'
    echo ' -e            : run under debugger control in your IDE (gdbserver)'
    echo ' -S            : do not change directory before executing target, eg. Stay in current directory'
    echo ' -v            : verbose mode'
    echo .
    exit 3;
}

while getopts ":deSv-" opt
do
    case $opt in
        :)
            echo "ERROR: -$OPTARG parameter missing, exiting!";
            showhelp;
        ;;
        d)
            doDebug=1;
        ;;
        e)
            doDebugServer=1;
        ;;
        S)
            doChangeDir=0;
        ;;
        v)
            doTrace=1;
        ;;
        -)
            break;
        ;;
        \?)
            showhelp;
        ;;
    esac
done

shift `expr $OPTIND - 1`

# find base directory for a given path
# param 1: path to start from
# param 2: is the path segment to search for
# param 3: value to return if search failed, default ""
searchBaseDirUp()
{
    start_dir="${1}";
    searchSegment="${2}";
    dirDefault="${3}";
    basePath="`cd \"$start_dir\" &&
        while [ ! -d \"${searchSegment}\" ] && [ \"\`pwd\`\" != / ]; do
            cd .. 2>/dev/null;
        done;
        pwd -P
    `";
    test -d "${basePath}/${searchSegment}" || basePath="${dirDefault}";
    echo "$basePath";
}

LIBDIR="lib"
BINDIR="bin"
CONFIGDIR="config"
SCRIPTDIR="scripts"
VARIANTDIR="Linux_glibc_2.9-x86_64-32_optimized"
BINARYNAME="CoastNTLMAuthTest"
BASEDIR="`searchBaseDirUp \"${SCRIPTPATH}\" \"${SCRIPTDIR}\"`"
export LIBDIR BINDIR CONFIGDIR SCRIPTDIR VARIANTDIR BINARYNAME BASEDIR

# find the base directory
LIBDIR_BASE="`searchBaseDirUp \"${SCRIPTPATH}\" \"${LIBDIR}\"`"

test -n "${LIBDIR_BASE}" || ( echo "Base directory not found containing [$LIBDIR], exiting."; exit 1 )

ABS_LIBDIR="${LIBDIR_BASE}/${LIBDIR}"
test -d "${ABS_LIBDIR}/${VARIANTDIR}" && ABS_LIBDIR="${ABS_LIBDIR}/$VARIANTDIR"

LD_LIBRARY_PATH="${ABS_LIBDIR}":$LD_LIBRARY_PATH
export LD_LIBRARY_PATH

BINDIR_BASE="`searchBaseDirUp \"${SCRIPTPATH}\" \"${BINDIR}\"`"

test -n "${BINDIR_BASE}" || ( echo "Base directory not found containing [$BINDIR], exiting."; exit 1 )

ABS_BINDIR="${BINDIR_BASE}/${BINDIR}"
test -d "${ABS_BINDIR}/${VARIANTDIR}" && ABS_BINDIR="${ABS_BINDIR}/$VARIANTDIR"


# generate gnu debugger command file which may be used for batch
# invocations of the debugger.
#
# param 1: is the name of the generated batch file
# param 2: binary to execute
# param 3: run executable in background, default 1, set to 0 to run gdb in foreground
# param 4.. arguments passed to the debugged program
#
generateGdbCommandFile()
{
    ggcfBatchFile="${1}";
    ggcfBinaryToExecute="${2}";
    ggcfRunInBackground=${3};
    test $# -ge 3 || return 1;
    shift 3
    ggcfServerOptions="$@";
    # <<-EOF ignore tabs, nice for formatting heredocs
cat > ${ggcfBatchFile} <<-EOF
	handle SIGSTOP nostop nopass
	handle SIGLWP  nostop pass
	handle SIGTERM nostop pass
	handle SIGINT  nostop pass
	set environment PATH=${PATH}
	set environment COAST_ROOT=${COAST_ROOT}
	set environment COAST_PATH=${COAST_PATH}
	set environment LD_LIBRARY_PATH=${LD_LIBRARY_PATH}
	set auto-solib-add 1
	# convert to Windows path on mingw (msys supplies it automatically to non-msys tools)
	file "${ggcfBinaryToExecute}"
	set args ${ggcfServerOptions}
EOF
    if [ $ggcfRunInBackground -eq 1 ]; then
cat >> ${ggcfBatchFile} <<-EOF
	set pagination 0
	run
	! echo "\`date +'%Y%m%d%H%M%S'\`: ========== GDB backtrace =========="
	backtrace full
	info registers
	x/16i \$pc
	thread apply all backtrace
	continue
	shell rm ${ggcfBatchFile}
	quit
EOF
    fi;
}

CMD="${ABS_BINDIR}/${BINARYNAME}"
test -x "${CMD}" || ( echo "binary [${CMD}] is not executable, aborting!"; exit 1 )

test ${doChangeDir} -eq 1 -a -d "${BINDIR_BASE}" && cd "${BINDIR_BASE}"

test ${doTrace} -eq 1 && ( cat <<EOF
Executing command [${CMD}]
`test -z "$@" || echo " with arguments   [$@]"`
 in directory     [`pwd`]
EOF
)

if [ ${doDebug:-0} -eq 1 ]; then
    cfg_gdbcommands="/tmp/`basename \"$0\"`_$$";
    generateGdbCommandFile "${cfg_gdbcommands}" "$CMD" 0 "$@"
    test ${doTrace} -eq 1 && echo "Generated gdb command file:"
    test ${doTrace} -eq 1 && cat ${cfg_gdbcommands}
    gdb --command ${cfg_gdbcommands}
elif [ ${doDebugServer:-0} -eq 1 ]; then
    gdbserver :${GDBSERVERPORT} "${CMD}"
else
    "$CMD" "$@"
fi

exit $?
